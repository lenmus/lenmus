<HTML>
<head><link rel=stylesheet type="text/css" href="wx.css">
<title>wxMidi</title></head>

<BODY BGCOLOR=#FFFFFF>
<A NAME="wxMidi"></A>

<FONT FACE="Arial, Lucida, Helvetica">

<H1>wxMidi overview</H1>
wxMidi is a set of classes to implement direct MIDI input/output communication. It is not intended to deal directly with MIDI files and so it does not include methods for reading, writing or playing MIDI files. The wxMidi component adresses the problem of sendind and receiving MIDI messages, to/from the user application and the MIDI hardware, in order to produce sounds, to read commands send from external MIDI devices, such as keyborads, or to send commands to those external devices from your application. Any method for playing MIDI files will require to use the lower level facilities provided by wxMidi.<P>

For a tutorial on MIDI you could see, for example, <A href="http://www.harmony-central.com/MIDI/Doc/tutorial.html">http://www.harmony-central.com/MIDI/Doc/tutorial.html</A><P>

wxMidi is mainly a wrapper for portmidi, a platform independent package to deal with MIDI sound. It is part of the portaudio package, that is developed by many computer music researchers and developers who, after considering many options, decided to endorse the work of Phil Burk and Ross Bencina who created the PortAudio library (<a href="http://www-2.cs.cmu.edu/~music/portmusic/">http://www-2.cs.cmu.edu/~music/portmusic/</a>). <P>

The main differences with portmidi are:<P>
<UL>
<LI>wxMidi provides a suitable interface, object oriented, to use portmidi with wxWidgets.</LI>
<LI>All strings has been moved from portmidi and adapted to support internationalization.</LI>
<LI>SysEx messages are not received in chunks with real-time messages interleaved. In wxMidi, sysex messages are received completed, in a single string of bytes, and any real-time message embeded is delivered before the sysex message is delivered.</LI>
<LI>All buffer allocation process for messages is now hiden in the wxMidi clases. User has not to worry abut this.</LI>
<LI>wxMidi also includes an additional feature, class wxMidiDatabaseGB, which provides methods for dealing with the General MIDI Standard (GM) instruments list.</LI>
</UL><P>

wxMidi is composed by several classes. <a href="wxMidiSystem.htm#wxMidiSystem">wxMidiSystem</a> is the top class of the MIDI hierachy and represents the whole MIDI system. It acts as an application's entry point to the MIDI music system, and it provides information about, and access to, the set of installed MIDI devices.<P>

The MIDI devices are represented by wxMidiDevice objects. A <A href="wxMidiDevice.htm#wxMidiDevice">wxMidiDevice</A> can be seen as a MIDI stream on which MIDI data traffic can be read or sent. Apart of the MIDI initialization and termination routines, all MIDI communication is achieved through a wxMidiDevice by using MIDI messages. It specializes into two classes: <A href="wxMidiDevice.htm#wxMidiInDevice">wxMidiInDevice</A> and <A href="wxMidiDevice.htm#wxMidiOutDevice">wxMidiOutDevice</A><P>

MIDI messages are represented by the <A HREF="#wxMidiMessage">wxMidiMessage</A> abstract object, that contains information about  the type, data length, and status byte of the raw MIDI message for which it serves as a wrapper. In addition, it provides a timestamp value that is used by devices involved in MIDI timing, such as sequencers. There are two derived clases: <A HREF="#wxMidiShortMessage">wxMidiShortMessage</A> and 
<A HREF="#wxMidiSysExMessage">wxMidiSysExMessage</A>.<P>

The wxMidi package also has a database with the General Midi standard (GM) instruments list. Instruments are grouped into sections, to facilitate the search for a specific instrument. The database includes methods to populate a combo box, a list box or, in general, any other control derived from <B>wxControlWithItems</B>. It is implemented by object <A href="wxMidiDatabaseGM.htm#wxMidiDatabaseGM">wxMidiDatabaseGM.</A><P>

<A HREF="#wxMidiQuickStart">wxMidi quick start</A><BR>
<A HREF="wxMidiMessage.htm#wxMidiMessages">wxMidi messages</A><BR>
<A HREF="wxMidiConstants.htm#wxMidiConstants">wxMidi constants and macros</A><BR>
<P>


<HR>
<A NAME="wxMidiQuickStart"></A>
<H3>wxMidi quick start</H3>
<P>
<B><FONT COLOR="#FF0000">Sending MIDI messages</FONT></B><P>

Using wxMidi basically requires the following steps:<p>
1. Access the wxMidiSystem instance and look for available MIDI devices:<P>
<PRE>
wxMidiSystem* pMidiSystem = wxMidiSystem::GetInstance();
int nMaxDevice = pMidiSystem->CountDevices();
</PRE>

2. Create an instance for the MIDI device you would like to use and open the device:<P>
<PRE>
// In this example we will use the first device available 
// (device number 0) assuming it is an output device. 
// In your application you should use a suitable device.
// See <a href="wxMidiSystem.htm#wxMidiSystemCountDevices">wxMidiSystem::CountDevices</a> for an
// example of how to load a combo box with the available
// devices, so the user can choose the device to use.

wxMidiOutDevice* pMidiOut = new wxMidiOutDevice(0);
pMidiOut->Open();

</PRE>

3. Prepare the message to send<P>
<PRE>
wxMidiShortMessage msg(0x90, 60, 127);

</PRE>

4. Send it:<P>

<PRE>
pMidiOut->Write(&msg);    

</PRE>

For very common messages, such as Note On or Note Off, steps 3 and 4 can be replaced by a call to the suitable method. For example:<P>
<PRE>
//Play a scale 

int scale[] = { 60, 62, 64, 65, 67, 69, 71, 72 };
#define SCALE_SIZE 8
int channel = 0, volume = 127;

for (int i = 0; i < SCALE_SIZE; i++) {
	pMidiOut->NoteOn(channel, scale[i], volume);
	::wxMilliSleep(200);	// wait 200ms
    	pMidiOut->NoteOff(channel, scale[i], volume);    
 }

</PRE>
&nbsp;<P>

<A name="wxMidiQuickStartReceiving" />
<B><FONT COLOR="#FF0000">Receiving messages</FONT></B><P>
The procedure is, basically, the same than for sending messages. The main diference is that in reception the user program does not conthol when the message is going to be received, so a method to be informed about the arrival of a message is needed. wxMidi provides two alternatives for this:<P>
1. By using events and an event handler method<P>
<UL>By defining an event handler method, the user program will be informed when a message has been received and will have the opportunity to process it. A commnad event with ID named wxEVT_MIDI_INPUT is defined in the wxMidi.h include file. The application program must request from the MIDI device to start listening by calling method StartListening() as in following example:
</UL><P>
<PRE>
BEGIN_EVENT_TABLE(MyFrame, wxFrame)
...
EVT_COMMAND (ID_MY_PANEL, wxEVT_MIDI_INPUT, MyFrame::OnMidiReceive)
...
END_EVENT_TABLE()

MyFrame::MyFrame(...)
{
    ....

    //Filter out active sensing messages (0xFE) and 
    //clock messages (0xF8 only)
    m_pInDev->SetFilter(wxMIDI_FILT_ACTIVE | wxMIDI_FILT_CLOCK);

    // empty the buffer after setting filter, just in case anything
    // got through
    m_pInDev->Flush();

    //now start a listening thread. An event wxEVT_MIDI_INPUT
    //will be produced when new input is detected
    m_pInDev->StartListening(this);

	...
}

void MyFrame::OnMidiReceive(wxCommandEvent &event)
{
    // loop to read and process all available msges.
    wxMidiError nErr;
    wxMidiMessage* pMsg;
    while (m_pInDev->Poll())
    {
        pMsg = m_pInDev->Read(&nError);
		
        //error checking and do something with the read message
        if (!nError) {
	...

	//delete message when no longer needed
	delete pMsg;
        }
    }
}

MyFrame::~MyFrame()
{
	....

    //Stop the lisening thread
    m_pInDev->StopListening(this);

	...
}



</PRE>
<P>
2. By polling<P>
<UL>Alternatively, the user application could interrogate the MIDI device, from time to time, to see if a message has been received and, in that case, read and process it. See an example of this in sample program midisound.</UL>
<P>

</FONT></BODY></HTML>
