\include ../../agdoc/replacements

\title    {How pitch is represented}

\toc 

\h1 {How pitch is represented}


\h2 {Requirements}
%%%-------------------

As new exercises are designed and implemented, new pitch representation requirements started to appear.

Frequently the issue of whether or not to represent explicitly the key signature accidentals by adding them to the note pitch, reappears. My current opinion is that it seems better to always include the accidentals in the representation (absolute pitch) and filter them out at layout phase.

Additional features, such as:

 * To support microtonality and melismatic intonation
 * To support 'no-pitch defined yet' value
 
also have to be taken into account.

For efficiency and to simplify computations, it would be very nice if the pitch representation could combine the diatonic pitch (step and octave) and accidentals in a single number.

An important requirement for music analysis is that it would be desirable that by subtracting two pitch representations we could easily get the interval, without more computations. After experimenting with several representations, I found on the web an \href0 {#r1} [article]\sup{[1]}, from Walter B. Hewlett describing representation systems with these properties. So I decided to test the proposed base-40 representation system. It has been, in fact, the best solution I fount to represent pitch for music analysis applications.

[1] - Walter B. Hewlett, "A Base-40 Number-line Representation of Musical Pitch Notation", Stanford, California, http://www.ccarh.org/publications/reprints/base40/


\h2 {How pitch is currently represented}
%%%----------------------------------------

All above mentioned issues are currently, except microtonality, have been currently  taken into account. Microtonality representation is yet an open issue to be solved in order to include new exercises, such as the planned 'Tunning exercise'.

**1. External representations**

    a) Absolute pitch (MusicXML style)
        * The pitch is represented by combining the note name, the octave and the accidentals.
        * The pitch is absolute, that is, it is not influenced by key signature accidentals,          accidentals in previous note, etc.
        * Accidentals are represented by the number of semitones (i.e. -1 for a flat, + 1 for a sharp). Decimal values can be used to represent microtones (i.e. +0.5 = a quarter of a tone).
    
    b) Relative pitch (LDP style)
        * The pitch is also represented by combining the note name, the octave and the accidentals.
        * Contrary to 'Absolute pitch' method, accidentals are relative to the context. That is, you have to write only those accidentals that are not implied by the key signature or that are not implied by a previous accidental in the same measure.
        * Microtonality is not allowed (yet).


To deal with external representations, when a note is going to be created and the note constructor has to assign meaning to the received parameters, three possibilities are currently defined in the program:

\code
{
// pitch type
enum lmEPitchType
{
    lm_ePitchAbsolute = 0,  // absolute pitch (MusicXML style), equal temperament tuning system
    lm_ePitchRelative,      // relative pitch (LDP style), equal temperament tuning system
    lm_ePitchNotDefined,    // pitch value is not yet defined
};

}

This enum is defined in file score/defs.h. The meaning of each value is as follows:

    lm_ePitchAbsolute
        * Absolute pitch (MusicXML style), equal temperament tuning system.
        Sound and look information totally independent:
        * Pitch is absolute, and is implied by combining Step, Octave and Alter.
        * Accidentals are just for rendering.
        
    lm_ePitchRelative
        * Relative pitch (LDP style), equal temperament tuning system
        * Notes defined as in hand writing; pitch depends on context (key signature
        and accidentals introduced by a previous note in the same measure) and its own
        accidentals:
        * Pitch is computed from Step, Octave, Accidentals and Context.
        * Alter is not used.
        
    lm_ePitchNotDefined
        * Pitch value is not yet defined. If it would be necessary to render or play back the note, program should assign it an arbitrary pitch and, if possible, add something (i.e. a change in colour) to show that the note has not yet pitch assigned.
        


**2. Internal representations**

All issue and methods to deal with internal pitch representation are coded in files score/Pitch.cpp & .h.

Currently, four different ways to encode pitch, and methods to translate from one representation into any other one, are defined:

a) Midi pitch (typedef %%lmMPitch%%)
    * A number representing the pitch in a chromatic scale. It is the same as the MIDI key number used in MIDI for representing pitch.
    * Equal temperament tunning assumed. This implies that there is no possibility to differentiate between enharmonic sounds, for instance, C sharp and D flat.
    * Intended to be used only for sound generation.
    * Usable for sweeps along the equal temperament sounds.
                
b) Diatonic pitch (typedef %%lmDPitch%%)
    * A number (int) representing the note in a diatonic scale. Only Step and Octave information.
    * Accidentals not represented -> Incomplete information.
    * Usable for sweeps along the diatonic note range.
    * TODO: Efficient conversion to lmNotePitch required.

c) Absolute pitch (class %%lmAPitch%%)
    * Chromatic absolute pitch implied by combining Diatonic pitch and Accidentals. No enharmonies assumed (i.e. C sharp is a different representation from D flat).
    * Currently implemented as a class with two int members (DPitch, Accidentals). A better alternative could be combining DPitch + Accidentals in a long: 16bits will be for DPitch and the other 16bits for accidentals
    * Optimal use: sweeps along the diatonic note range
                
d) Base-40 pitch (typedef %%lmFPitch%%)
    * (F stands for \i{Fourty}). It is an absolute pitch representation, with an interesting property: is interval-invariant, that is, the number obtained by subtracting two pitches represents the interval between them. Therefore, this representation is specially useful to deal with intervals.
    * Each octave requires an range of 40 values. So to represent 10 octaves (C0-B9) a range of 400 is required. An %%int%% is enough.

\tip
{
    lmFPitch representation has shown to be optimal for representing pitch in cases where music analysis is an objective, as it greatly simplifies analysing intervals and chords.
}



\h1 {Representing chords and intervals}
%%%-------------------------------------

In the internal socre representation (%%lmScore%%) chords do not have any special representation: they are just notes played at the same time. There exists an %%lmChord%% class, but it is a helper class to render chords.

But in certain cases (i.e. for music analysis and in exercises) it is necessary to have a  specific representation and specific methods to deal with chords. For this purpose, class %%lmChordManager%% (in auxmusic/ChordManager.h & .cpp) has been created. The class was named %%lmChordManager%% as name %%lmChord%% was already used in the aforementioned helper class. Moreover, as this class has methods to deal with chords, the adjective <i>manager</i> was considered not too bad.


\h2 {The lmChordManager class}
%%%--------------------------------

Class %%lmChordManager%% represents a chord. The chord is internally modelled by an array of note pitches.

Currently, %%lmChordManager%% is only used in chords and cadences exercises. Therefore, only the methods needed for these exercises has been created. They are, basically:

 * given a root note, the chord type, and the inversion create the chord.
 * get the notes that form the chord
 
To encode chord type, enum %%lmEChordType%% has been defined.

\code
{
enum lmEChordType
{
    // Triads
    ect_MajorTriad = 0,
    ect_MinorTriad,
    ect_AugTriad,
    ect_DimTriad,
    ect_Suspended_4th,
    ect_Suspended_2nd,
    ect_LastTriad = ect_Suspended_2nd,

    // Seventh chords
    ect_MajorSeventh,
    ect_DominantSeventh,
    ect_MinorSeventh,
    ect_DimSeventh,
    ect_HalfDimSeventh,
    ect_AugMajorSeventh,
    ect_AugSeventh,
    ect_MinorMajorSeventh,
    ect_LastSeventh = ect_MinorMajorSeventh,

    // Sixth chords
    ect_MajorSixth,
    ect_MinorSixth,
    ect_AugSixth,
    ect_LastSixth = ect_AugSixth,

    //last element, to signal End Of Table
    ect_Max
};
}

To add more chord types it is necessary to modify this enum and the table defined in %%lmChordManager%% implementation:

\code
{
static lmChordInfo tData[ect_Max] = {
    { 3, { lm_M3, lm_p5, lmNIL }},      //MT        - MajorTriad
    { 3, { lm_m3, lm_p5, lmNIL }},      //mT        - MinorTriad
    { 3, { lm_M3, lm_a5, lmNIL }},      //aT        - AugTriad
    { 3, { lm_m3, lm_d5, lmNIL }},      //dT        - DimTriad
    { 3, { lm_p4, lm_p5, lmNIL }},      //I,IV,V    - Suspended_4th
    { 3, { lm_M2, lm_p5, lmNIL }},      //I,II,V    - Suspended_2nd
    { 4, { lm_M3, lm_p5, lm_M7 }},      //MT + M7   - MajorSeventh
    ...
};
}

This table encodes each chord type by specifying:

 * the number of notes in the chord, and
 * the intervals between the root note and the others when in root position.
 
For example, line
\code
{
{ 4, { lm_M3, lm_p5, lm_M7 }},      //MT + M7   - MajorSeventh
}
says that a major seventh chord has four notes, and the intervals between them are a major third (%%lm_M3%%), a perfect fifth (%%lm_p5%%) and a major seventh (%%lm_M7%%). Intervals are encoded using symbolic constants defined in score/Pitch.h.


\h2 {Representing intervals}
%%%-------------------------

\h2 {Intervals in FPitch: typedef lmFInvtal}
%%%-------------------------

Representing pitch using %%lmFPitch%% is the best approach to represent intervals for computations. An %%lmFPitch%% it is just an integer number, but it has an interesting property for computing intervals:

 * The interval between two FPitches is just the difference between the two FPitches.
 
The resulting number represents the interval. A typedef %%lmFIntval%% is defined for this (in score/Pitch.h). %%lmFIntval%% has interesting properties:

 * FIntervals can be added/substracted. For example: p5-3M = 3m (23-12=11), and the result represents correctly the new interval.
 
 * Intervals greater than one octave are computed by adding 40 (p8) for each octave.
For example, a Major 10th is M3+p8 = 12+40 = 52.


\h2 {Classes lmInterval and lmNoteBits}
%%%---------------------------------------

One of the first exercises added to LenMus program was 'intervals identification'. When I coded it, I didn't pay much attention to the problem of managing intervals. I was only interested in some quick representation for that exercise. Due to time constrains, this initial representation  is still in use in the program and code using it has not yet be changed to use %%lmFIntval%%. This deprecated class is %%lmInterval%% (defined in auxmusic/Interval.h & .cpp). There are also some global functions defined to compute intervals, but they should not be used. Any new code dealing with intervals should be based on %%lmFPitch%% and %%lmFIntval%%.

Associated to this class (and also deprecated) there is typedef %%lmNoteBits%% (defined in auxmusic/Conversion.h). It is a pitch representation struct, used to compute intervals.  Any new code should use %%lmFPitch%% or any of the other pitch representation classes defined previously in this chapter.

%%lmNoteBits%% is equivalent to %%lmAPitch%% but it is a less compact representation. And member %%nStepSemitones%% is redundant:

 \code
 {
typedef struct lmNoteBitsStruct {
    int nStep;              // 'c'=0, 'd'=1, 'e'=2, 'f'=3, 'g'=4, 'a'=5, 'b'=6
    int nOctave;            // 0..9
    int nAccidentals;       // '--'=-1, '-'=-1, ''=0, '+'=+1, '++'=+2
    int nStepSemitones;     // 'c'=0, 'd'=2, 'e'=4, 'f'=5, 'g'=7, 'a'=9, 'b'=11
} lmNoteBits;
}
                               
 

\h2 {Annex. Pitch values in different representations}
%%%---------------------------------------

\ssv_table[Table 1. Pitch values in different representations; anchor=TAB1; class=simpletable]
{
\th{ name || Octave || MIDI || DPitch   || FPitch   || Observations }
\al{ <            >       >          >        >         <     }
  rest      any         0            0        ~_       Any~_rest
  (c-1)    -1           1            ~_       ~_        ~_
  c0        0           12           1        ~_        Do2~_de~_la~_subcontraoctava~_(16.35~_Hz)
  d0        0           14           2        ~_        ~_
  e0        0           16           3        ~_        ~_
  f0        0           17           4        ~_        ~_
  g0        0           19           5        ~_        ~_
  a0        0           21           6        ~_        ~_
  b0        0           23           7        ~_        ~_
  c1        1           24           8        ~_        Do1~_de~_la~_contraoctava
  c2        2           36           15       ~_        Do~_de~_la~_gran~_octava
  c3        3           48           22       ~_        do~_de~_la~_pequena~_octava
  c4        4           60           29       ~_        do1~_de~_la~_octava~_primera~_(a4~_=~_440Hz)~_      
  d4        4           62           30       ~_        ~_
  e4        4           64           31       ~_        ~_
  f4        4           65           32       ~_        ~_
  ...       ~_          ~_           ~_       ~_        ~_
  c5        5           72           36       ~_        do2~_de~_la~_octava~_segunda
  c6        6           84           43       ~_        do3~_de~_la~_octava~_tercera
  c7        7           96           50       ~_        do4~_de~_la~_octava~_cuarta
  c8        8           108          57       ~_        do5~_de~_la~_octava~_quinta~_(4,186~_Hz)
  c9        9           120          64       ~_        ~_
  d9        9           122          65       ~_        ~_
  e9        9           124          66       ~_        ~_
  f9        9           125          67       ~_        ~_
  g9        9           127          68       ~_        ~_
}

%%*

  Accidentals are represented by minus (-) and plus (+) signs before the note name
       -  : flat
       +  : sharp
       -- : double flat
       ++ : sharp-sharp (two sharps)
       =  : natural
       =- : natural-flat
       =+ : natural-sharp
       x  : double sharp
  i.e.:  ++c3, =+c3, +c3, =c3, -c3, --c3, =-c3, xc3

---------------------------------------------------------------------------------------       
  
  

**3. Open issues**

    ePitchNoteCents
        * Absolute pitch + cents deviation.

      
new (HCHord):                
                Internal: DPitch + Accidentals
                * Better usability for sweeps along the diatonic note range
                
 lmUPitch:      Microtonal pitch:
                - CPitch + cents deviation?
                - A previous operation to set up scale intervals and number of keys? 
                    Then lmUpitch could be just the key+octave
                
                
 LDP source:    String "accidentals-step-octave" (i.e. '=+c3'). Relative to context.
                * Difficult to manage.
                * Uncertainty about meaning as in some methods it is used as an
                  absolute pitch.
                * Incomplete information or complex to analyse, as at least key signature
                  must be taken into account.


Microtonal representation

    
FREQUENCY DATA FORMAT (used by MTS)
The frequency resolution of MIDI Tuning should be stringent enough to satisfy most demands of music and experimentation. The specification provides resolution somewhat finer than one-hundredth of a cent. 

Frequency data shall be defined in units which are fractions of a semitone. The frequency range starts at MIDI note 0, C = 8.1758 Hz, and extends above MIDI note 127, G = 12543.875 Hz. The first byte of the frequency data word specifies the nearest equal-tempered semitone below the frequency. The next two bytes (14 bits) specify the fraction of 100 cents above the semitone at which the frequency lies. Effective resolution = 100 cents / 214 = .0061 cents.

One of these values ( 7F 7F 7F ) is reserved to indicate not frequency data but a "no change" condition. When an instrument receives these bytes as frequency data, it should make no change to its stored frequency data for that MIDI key number. This is to prevent instruments which do not use the full range of 128 MIDI key numbers from sending erroneous tuning data to instrument which do use the full range. The three-byte frequency representation may be interpreted as follows:

0xxxxxxx 0abcdefg 0hijklmn

xxxxxxx  = semitone 
abcdefghijklmn = fraction of semitone, in .0061-cent units 

Examples of frequency data:
00 00 00 = 8.1758 Hz (C – normal tuning of MIDI key no. 0)
00 00 01 = 8.2104 Hz
01 00 00 = 8.6620 Hz
0C 00 00 = 16.3516 Hz
3C 00 00 = 261.6256 Hz (middle C)
3D 00 00 = 277.1827 Hz (C# – normal tuning of MIDI key no. 61)
44 7F 7F = 439.9984 Hz
45 00 00 = 440.0000 Hz (A-440)
45 00 01 = 440.0016 Hz
78 00 00 = 8372.0190 Hz (C – normal tuning of MIDI key no. 120)
78 00 01 = 8372.0630 Hz
7F 00 00 = 12543.8800 Hz (G – normal tuning of MIDI key no. 127)
7F 00 01 = 12543.9200 Hz
7F 7F 7E = 13289.7300 Hz (top of range)
7F 7F 7F = no change (reserved)


Using pitch bend
-----------------

Pitch resolution should be displayed in cents in the actual resolution used by the instrument. To make it "easier" for users, most manufacturers display microtunning offsets in whole number cents: -2, -1, 0, +1, +2, etc. Unfortunately, the internal resolution rarely, if ever, matches these values. Many synthesizers have an internal pitch resolution, set in software, of 768 steps per octave or 64 steps per semitone. This is 1.5625 cents. So the actual microtunning offsets are 0, 1.5625, 3.125, 4.6875, 6.25, 7.8125, etc. This results in an additional amount of pitch tuning error for the user due to the ambiguity of the whole number offset to internal offset resolution. Let's say the user wants to set a note to +7.4 cents over the equal tempered value. The displayed microtunning value selected would be +7 cents, but the actual tuning offset would probably be +6.25 cents since that is closest to + 7 cents. In actuality +7.81 cents would have been far more accurate. Showing the cents value to two decimal places (0, 1.56, 3.12, 4.69, etc.) would be sufficient, and much more accurate.

Pitch resolution of 1 cent is generally considered to be sufficient resolution for equal temperament. But this is not the case for just intonation, and here's why. Just intonation is based upon eliminating the beats we hear in all tempered harmonies. When you listen to an a cappella choir or a string quartet, their natural instinct is to play the pure harmonies of just intonation. These harmonies can only be achieved by eliminating the beats between any intervals sounded. While it is generally agreed that pitch perception is limited to 1-2 cents for melodies, harmonies in just intonation can be corrupted by this pitch resolution because anyone can still hear the beats between notes. A limited polling of practicing microtonalists has indicated that 0.1 cent pitch resolution is a suitable value for most music.

The pitch bend range is adjustable via a standard System Exclusive message. We use a=1/6, which is the default on most synthesizers anyway.

-------------------------------------------------------------------------------------------
Cent (music)
From Wikipedia, the free encyclopedia

The cent is a logarithmic unit of measure used for musical intervals. Typically cents are used to measure extremely small intervals, or to compare the sizes of comparable intervals in different tuning systems, and in fact the interval of one cent is much too small to be heard between successive notes.

1200 cents are equal to one octave (a frequency ratio of 2:1) and an equally tempered semitone (the interval between two adjacent piano keys) is equal to 100 cents. This means that a cent is precisely equal to 2**1/1200, the 1200th root of 2, which is approximately 1.0005777895.

If you know the frequencies a and b of two notes, the number of cents measuring the interval between them may be calculated by the following formula:

    n = 1200 * log2(a/b)  aprox.= 3986 * log10(a/b)

 
Likewise, if you know a note b and the number n of cents in the interval, then the other note a may be calculated by:

    a = b * 2**(n/1200)

 
To compare different tuning systems, convert the various interval sizes into cents. For example, in just intonation the major third is represented by the frequency ratio 5:4. Applying the formula at the top shows this to be about 386 cents. The equivalent interval on the equal-tempered piano would be 400 cents. The difference, 14 cents, is about a seventh of a half step, easily audible. The just noticeable difference for this unit is about 6 cents.


*%%
