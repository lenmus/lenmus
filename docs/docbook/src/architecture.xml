<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
               "http://www.oasis-open.org/docbook/xml/5.0b.5/docbook.dtd">

<book id="book">
<bookinfo>
<title>LenMus program. Architecture and internal design</title>
<para>Version 0.1. Revision: September 2006</para>

<author>
<surname>LenMus project</surname>
</author>

<legalnotice id="legal_notice">

<title>Legal Notice</title>
<para>Permission is granted to copy, distribute, and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or any later
version published by the Free Software Foundation; with no Invariant Sections, 
no Front-Cover Texts, and no Back-Cover Texts. A copy of the license
is available at 
<ulink url="http://www.gnu.org/licenses/fdl.html">http://www.gnu.org/licenses/fdl.html</ulink>.
</para>

<para>This document may be copied and distributed in any medium, either
commercially or noncommercially, provided that the GNU Free Documentation
License (FDL), the copyright notices, and the license notice saying
the GNU FDL applies to the document are reproduced in all copies, 
and that you add no other conditions whatsoever to those of the GNU FDL. 
</para>

</legalnotice>

<copyright>
<year>2002-2006</year>
<holder>Cecilio Salmeron</holder>
</copyright>
</bookinfo>

<preface id="preface">
<title>Preface</title>

<para>
To be written.
</para>
</preface>

<chapter id="chIntro">
<title>LenMus architecture</title>

<sect1>
<title>Source code organization</title>
<para>LenMus has four main parts:</para>
<simplelist>
    <listitem>The application management:
      <simplelist>
          <listitem>Classes to support the GUI (all in 'app' folder). The main application
            modules are TheApp, and MainFrame. When the program runs, execution starts
            in TheApp:OnInit().
            There, the main frame is created and all initializations take place.</listitem>

          <listitem>Dialogs are, normally,
          build using XRC mechanism; the xrc files that define the dialog layout are
          in folder 'xrc'. For each dialog there is a class in 'app' folder</listitem>

    </simplelist></listitem>

    <listitem>The score representation and management mechanism:
      <simplelist>
          <listitem>Classes to support the internal representation of scores
          (in 'score' folder).</listitem>

          <listitem>Clases to deal with sound: wave files reproduction, MIDI interface, and
          scores playback (SoundManager module).</listitem>

          <listitem>Currently I am splitting the renderization process. So all score
          renderization is being redesigned and moved to folder 'graphics'</listitem>

    </simplelist></listitem>

    <listitem>The eBooks mechanism and the exercises. eBooks are external files in html
    format. Appart of the normal html tags, the eBooks pages have tags
    &lt;object type="application/lenmus"&gt; to include LenMus controls.
    These controls serve to render scores and to implement exercises.
      <simplelist>
          <listitem>Controls for eBooks are in folder 'exercises'. They are like
          dialogs, but all its customization is defined by Constrains' objects.</listitem>

          <listitem>The controller to display eBooks and the parser for tag
          &lt;object&gt; are in folder 'html'</listitem>

          <listitem>Folder 'auxmusic' contains classes nedeed in exercises to deal with music
          in source code, compute intervals, chords, etc.</listitem>

    </simplelist></listitem>

    <listitem>Other auxiliary modules:
      <simplelist>
          <listitem>Folder 'xml_parser' contains classes to support MusicXML import.</listitem>

          <listitem>Folder 'ldp_parser' contains classes to support LDP language.</listitem>

          <listitem>Folder 'updater' contains classes to manage the web updater.</listitem>

          <listitem>Folder 'options' contains classes to manage the user options settings.</listitem>

          <listitem>Folder 'globals' contains classes to access to global issues such as colors,
          paths, etc..</listitem>

          <listitem>Folder 'widgets' only contains the ruler object (not finished) to be
          used with the score editor</listitem>

    </simplelist></listitem>


</simplelist>
</sect1>



<sect1>
<title>Architecture</title>

<para>
LenMus architecture is based on the document/view architecture as this makes it easy to 
support multiple views, multiple document types, splitter windows, and other valuable 
user-interface features. the document/view functionality is provided by wxWidgets classes.
</para>

</para>
The document/view implementation separates the data itself from its display and from user 
operations on the data. All changes to the data are managed through the document class. 
The view calls this interface to access and update the data.
</para>

</para>
A document manager has a list of documents. Each document represents a music score and
is modelled by class lmScoreDoc.
</para>

<para>
Documents, their associated views, and the frame windows that frame the views are created by 
a document template. The document template is responsible for creating and managing all 
documents of one document type.
</para>

<para>
Data management is separated into two main classes:
</para>

<para>
The lmScoreDocument contains the score and  
represents the unit of data that the user typically opens with the Open command on the 
File menu and saves with the Save command on the File menu.
</para>

<para>
I don't like the MDI approach. It is also deprecated by Microsoft. 
My choice is a master application window with a ToolBar for tools and a wxNotebook
containing the documents.
</para>

</sect1>



<sect1>
<title>The lmScoreView class</title>

<para>
The lmScoreView class provides the functionality for viewing and editing a lmScoreDocument.
A lmScoreView is attached to a lmScoreDocument and acts as an intermediary 
between the document and the user: the view renders an image of the document on the screen 
and interprets user input as operations upon the document. The view also renders the image 
for both printing and print preview.
</para>

<para>
The view deals with two objects: the frame and the canvas.
</para>

<para>
When a view is created (via main menu 'file > new'  or 'file > open') class wxDocTemplate
invokes ::CreateDocument and ::CreateView. This last one creates the lmScoreView object and 
invokes lmScoreView::OnCreate.
In this method the lmScoreView object request from the App to create a new child frame-window
(method CreateProjectFrame). The App object then creates the child MDI frame (method CreateCanvas) and
show it (method Show). The Show operation request the view to display itself (method OnDraw). Also, when the frame must be redrawn it invokes the view OnDraw.
</para>

<para>
More than one view can share a frame window, as in the
case of a splitter window.
</para>

<para>
All drawing operations are made through a device-context (DC) object, which encapsulates the operating
system APIs for drawing lines, shapes, and text, and allow device-independent drawing. 
</para>

</sect1>



<sect1>
<title>Frame windows</title>

<para>
In addition, it is needed a frame or window class to contain the view.
</para>

<para>
A frame is a container window that can be moved and resized, can have a border and can have
additional features, such as a menu. For edition the lmScoreCanvas will be contained
in a frame: lmEditFrame, an wxDocMDIChildFrame.
It contains the "canvas" (DC) on which all drawing and interaction takes place, as well as
additional user interface items such as the window frame, menus, scroll bars, etc.
The frame-window class manages the frame, and a view class manages the contents. 
</para>

<para>
frame windows are responsible for numerous tasks involved in coordinating the frame with its 
view and with the application.
The frame window also forwards commands to its views and can respond to notification 
messages from control windows. 
a frame window keeps track of a currently active view. If the frame window contains more 
than one view, as for example in a splitter window, the current view is the most recent 
view in use. The active view is independent of the active window in Windows or the current 
input focus.
</para>

<para>
There is a main frame window in LenMus (class lmMainFrame). Inside this frame
two MIDI child windows can be opened:
</para>

<para>
    - lmEditFrame: MDI Child windows that contains the lmScoreCanvas
    - lmTextBookFrame: MDI Child window that contains the eMusicBook controller
</para>

</sect1>



<sect1>
<title>Score renderization</title>

<para>
There are two classes to render a score. Class lmScoreView, in app folder, is to support
score edition and class lmScoreAuxCtrol, in folder 'exercises', is a control to
display a score to be used in other controls for exercises.
</para>


</sect1>

<sect1>
<title>GraphicManager, Paper, and DC</title>

<sect2>
<title>The GraphicManager: renderization of scores</title>

<para>
Class lmGraphicManager stores and manages all score renderization issues.

Needs:

- To control and manage the renderization process:
    - derive the graphical representation
    - compute the position of all objects
    - render the graphic model into the canvas
    
    
It receives three parameters: 
    1. the lmScore to render, 
    2. the lmPaper on which the score has to be rendered
    3. the Renderization options

Renderization takes place in two phases:
    1. method Layout() is responsible for building the graphic model and doing the measure phase.
    2. method Render() does the drawing phase
    

The lmGraphicManager responsibilities are:
- it manages the offscreen bitmaps that receives all drawing operations
- it is a container for the lmPaper object on which to write.
- it is responsible for all scale and unit conversion methods
- other graphic management methods, such as exporting the score as images.
    

</para>

<para>
Renderization options, should be in the score? in the view?

If we consider a notation editor all renderization issues are part of the file describing 
the score

If we consider only the score as its musical contents then renderization parameters are
part of the view: depending on the type of view the renderization parameters could vary.

Conclusions:

1. The external score file must include all renderization parameters related to renderizating
    the score in the different posible views (i.e. paper, sound, ...) so that the document
    is always rendered/printed/interpreted as the author set it (i.e. as a 'PDF document').
    Nevertheless the user, by using the edition options, would be able to alter anything.
    
2. In the doc/view model there could be different views of the same score, if they share
    the renderization parameters the views will be the equal. (Well, if the type of view
    is the same - paper score - this is logical and coherent, so no problem) 
    
From 1 & 2 ==> All parameters for renderization are part of the document.

</para>

</sect2>



<sect2>
<title>lmPaper class</title>

<para>
A 'lmPaper' is the generic canvas on which the score is rendered plus a set of methods to do
basic drawing. It might be a display
device, a printer, etc. It can be consitered as a high-level DC. Basically it is a DC 
on which to write and draw, some methods
for basic drawing, and methods to deal with unit conversion and virtual paper cursor positioning.

By encapsulating the DC in lmPaper it is posible to use different strategies for
renderization (anti-aliased, direct DC, offscreen bitmaps, double buffering, etc.) 
without having to change application code.

The lmPaper responsibilities are:
- it is a container for the DC object on which to write and hides it.
- it is responsible for all scale and unit conversion methods
- it is responsible for informing the staff objects about page margins, spacings, 
    layout, etc.
        
</para>
                
<para>
Everything drawn to a view is drawn with a lmPaper object, which draws to
a bitmap buffer. When drawing is ready, lmScoreView blits the buffer to the display window.
This garanties flicker free drawing, and makes it possible to optimize redrawing in many ways. 
The steps to follow are:
1. The view creates an lmPaper object and sets up the DC
    m_graphMngr.Prepare(pScore, xPageSize, yPageSize, m_rScale, &m_Paper);
2. The view creates an lmGraphicManager object and calls lmGraphicManager.Prepare().
    Prepare is responsible for doing the measurement phase.
3. The view asks lmGraphicManager to render the necessary score pages, by invoking
    method lmGraphicManager.Render(). This method will perform all 
    renderization on a memory bitmap or directly, on the paper DC, depending on
    a flag received as parameter. This facility is intended for printing.


For print and print-preview the lmPrintout object invokes lmScoreView::DrawPage(). This
method is responsible of drawing the requested page and receives the page size in pixels
Currently, it does a direct renderization on printer DC. The steps followed are:

    m_Paper.SetDC(pDC);           //the layout phase requires a DC
    m_graphMngr.Prepare(pScore, nWithDC, nHeighDC, (double)actualScale, &m_Paper);
    m_graphMngr.Render(lmNO_BITMAPS, nPage);        //direct renderization on DC


</para>
                
</sect2>                


<sect2>
<title>Offscreen bitmaps management</title>


As the score is now divided into pages (BoxPage) there is no need to have all
bitmaps generated, just only the ones needed for the pages being displayed.

So, let's start with one bitmap for the first page. As the score is scrolled
we reach a second page, and a second bitmap is added.
* Q-> When to delete first page bitmap?

* A1 -> Lets assign a maximum amount memory for bitmaps. Bitmaps pages will be deleted
when no more memory available for bitmaps. The last recently used bitmaps are
the deleted and space reused for new bitmaps.

* A2 -> The view have information about pages currently visible. When scroll takes
place the view will inform about pages now visible. All other bitmaps will be deleted;
as an exception those for previous page and next page will be kept (if enough
memory) for smooth scrolling to these most probable pages.

</sect2>


</sect1>

</chapter>


<!-- =============================================================== -->
<!-- ======================    Units       ========================= -->
<!-- =============================================================== -->

<chapter id="chUnits">
<title>Logical and device units</title>

<sect1>
<title>Unit types</title>

<para>

    Logical units
        The "logical coordinates space", also named "world space" represents the virtual paper on which real music
        sheets are arranged according to the layout chossen by the user.

    Device units
        The "device coordinates space" representes the physical redering device (display,
        printer, ...) on which the score is rendered. The pixel is the usual unit in this
        space. 
    
    Program will operate on the logical coordinates space. Operation in device coordinates
    and transformation to/from device coordinates will be restricted to low program
    layers.

</para>


<sect1>
<title>Considerations for the choice of logical units and data types</title>

<sect2>
<title>Precision</title>

<para>
    Los atributos de posición, en MusicXML (common.dtd), utilizan unidades relativas: 
    décimas del espacio entre líneas de pentagrama . Ahora bien, espaciado entre líneas y, 
    en consecuencia, todos los demas valores relativos a esta medida de un pentagrama, debe 
    poder establecerse para cada pentagrama, ya que en una misma pieza pueden coexistir 
    pentagramas de distinto tamaño; por ejemplo, en partituras de piano en obras para varios 
    instrumentos, el piano va en grande mientras que la línea para el otro instrumento va en 
    pequeñito. En consecuencia, no parece una unidad adecuada para una página en la que se 
    mezclen pentagramas de distinto tamaño y habrá que utilizar una unidad que no varíe 
    entre pentagramas, al menos para  parámetros no asociados a un solo pentagrama, 
    tales como espaciados entre pentagramas o márgenes de página. Para estos parámetros 
    se decide utilizar como unidad  una décima de milímetro .  

    En PDF el posicionamiento en el user space se mide por defecto en 1/72 de pulgada, 
    ya que esa unidad es ampliamente utilizada en la industria tipográfica y equivale, 
    aproximadamente, a un punto tipográfico. Su valor es de 0,35 mm. (parece poco precisa). 
    Para fonts utiliza una resolución 1000 veces mayor (¿sería 0,001 mm?). Además, las unidades en el user 
    space pueden definirse con otra precisión distinta, según necesidades. 

    In MusicXML, units are fixed and relative
    las unidades son fijas y relativas, y utiliza como unidad una décima del espacio entre 
    líneas de pentagrama. Suponiendo un espaciado entre líneas de 3mm tendríamos una 
    precisión de 0,3 mm, del estilo de la estándar en PDF. Como cuesta lo mismo, me decanto 
    por permitir más precisión y que pueda variarse según necesidades, según hace PDF.

    One tenth of a millimeter seems to be enough precision for positioning objects but
    cumulative truncation errors are inaceptable. Therefore, at least a couple of decimal 
    figures should be taken into account during computations.
    Another posibilitry is to the use of one thousandth of a mm (one micron) as the choice
    for logical units and operate always with integers.
</para>

</sect2>


<sect2>
<title>2. Paper size</title>

<para>
    Paper size: let's consider at maximum a DIN A2 paper. This is:
        42.0 x 59.4 cm
        420 x 590 in mm
        4200 x 5900 in tenths of a mm
        42,000 x 59,400 in hundredths of a mm
        420,000 x 594,000 in thousandths of a mm (one micron)
    so a variable of type int32 (-2,146,483,648 to +2,147,483,647) has enough precision 
    and no overflow problems (maximum paper size would be  2.1 Km using the micron
    as logical unit !).
    Another posibility is to use float, as 6 significative digits is enough to deal with the
    greatest numbers expresed either in tenths of a mm or in microns. Also, a float
    has two advantages: 1) avoiding truncation errors during computations; and 2)
    a trivial upgrade to double if more precision is required in future.
</para>

</sect2>


<sect2>
<title>Device units: wxWidgets data types</title>

<para>
    Device units are always pixels (or dots, for printers).
</para>

<para>
    wxCoord is the basic type used by wxWidgets for all screen and DC coordinates. It is
    allways an int32 to allow for big virtual canvases. Other types extensively used in
    DC and screen methods are wxPoint, wxRect and wxSize. They use internally type int to
    store coordinates.
</para>
<para>
    To implement anti-aliasing it is necessary to use subpixel accuracy, that is, to consider
    fractions of a pixel. Therefore, for anti-aliasing, device units must be fractional.
    For example, AGG uses either doubles or int(24,8).
</para>
<para>
    As a limit case, let's consider at maximum a DIN A2 paper (42.0 x 59.4 cm) and printer
    with a resolution of 3048 dpi (1200 dots per centimeter). This will give an space of
    50,400 x 71,280 dots. Therefore
    a variable of type int32 (-2,146,483,648 to +2,147,483,647) has enough precision.
    And for anti-aliasing int24,8 also has enough precision as it allows for 16M.
    Also a float (6-digit precision) will be enough, and has the advantage of avoiding
    truncation errors during computations and a trivial upgrade to double if more
    precision where required.
</para>

</sect2>


<sect2>
<title>4. Device Context mapping mode</title>

<para>
    Maximum resolution wxWidgets mapping mode is MM_LOMETRIC, whose units are tenths of a mm.
    But greater precision can be easily achieved just by using MM_LOMETRIC and using a
    scaling factor. For example, to use the micron as logical unit the scaling factor 
    would be 0.01. This scaling factor must multiply the scaling factor used for zooming
    the the view.
</para>

</sect2>


<sect2>
<title>Final conclusions</title>

<para>
    We are going to use two world units:
      - Logical units: to use in those cases in which it is necessary to refer to real world, 
        such as when specifying the physical size of the paper to use. The choosen unit will
        be the micron (one thousand of a millimeter) and will be called "Micron" in the
        program.

      - Relative units (tenths of distance between staff lines) for all other cases. For 
      example to specify a note position. This unit will be called "Tenth" in the program.

    For future portability and to improve program legibility we are going to use our own
    types:
        lmLUnits - for logical units. Mapped to float
        lmTenths - for staff relative units. Mapped to float
        lmPixels - for device units. Mapped to int32

    For calculations, all methods will operate (unless strictly necessary) in logical units.
    As the precision is one micron, cumulative truncation errors are neglectable.
</para>

</sect2>




</sect1>

</chapter>



<!-- =============================================================== -->
<!-- ======================    The end     ========================= -->
<!-- =============================================================== -->


</book>

