<HTML>
<head><link rel=stylesheet type="text/css" href="wx.css">
<title>wxMidi constants and macros</title></head>

<BODY BGCOLOR=#FFFFFF>
<FONT FACE="Arial, Lucida, Helvetica">

<A NAME="wxMidiConstants"></A>
<H2>wxMidi constants and macros</H2>

<A href="#wxMidiConstantsMacros">Macros and miscellaneous constants</A><P>
<A href="#wxMidiFilterCodes">wxMidi filter codes</A><P>
<A href="#wxMidiErrorCodes">wxMidiError codes</A><P>

<HR>
<A NAME="wxMidiConstantsMacros"></A>
<H2>Macros and miscellaneous constants</H2>

<A name="wxMIDI_VERSION"/>
<B>wxMIDI_VERSION</B>
<UL>Constant. wxString with wxMidi version such as "1.0".</UL><P>

<A name="wxEVT_MIDI_INPUT"/>
<B>wxEVT_MIDI_INPUT</B>
<UL>ID for a command event that is triggered when a new MIDI message is available to be read. This event is only triggered if the user application has called method 
<A href="wxMidiDevice.htm#wxMidiInDeviceStartListening">wxMidiInDevice::StartListening</A>.</UL><P>

<A name="wxMIDI_CHANNEL"/>
<B>wxMIDI_CHANNEL</B>
<UL>Macro to be used in method 
<A href="wxMidiDevice.htm#wxMidiInDeviceSetChannelMask">wxMidiInDevice::SetChannelMask</A>.
This method requires a mask value that is a 16-bit bitfield with bits set to signal the appropriate channels.
Macro  wxMIDI_CHANNEL can assist in preparing this mask. For example, to set for receiving input only from 
channel 1, prepare the mask with wxMIDI_CHANNEL(1). <P>
   Multiple channels should be OR'd together, like
wxMIDI_CHANNEL(10) | wxMIDI_CHANNEL(11).
</UL><P>


<!-- ======================================================================================= -->


<HR>
<a name="wxMidiFilterCodes"/>
<H2>wxMidi filter codes</H2>

<B>wxMIDI_NO_FILTER</B>
<UL>No filter. All MIDI messages will be delivered to user application.</UL><P>
<B>wxMIDI_FILT_ACTIVE</B>
<UL>Filter active sensing messages (0xFE).</UL><P>
<B>wxMIDI_FILT_SYSEX</B>
<UL>Filter system exclusive messages (0xF0).</UL><P>
<B>wxMIDI_FILT_CLOCK</B>
<UL>Filter real-time clock messages (0xF8 only, does not filter clock start, etc.).</UL><P>
<B>wxMIDI_FILT_PLAY</B>
<UL>Filter play messages (start 0xFA, stop 0xFC, continue 0xFB).</UL><P>
<B>wxMIDI_FILT_F9</B> and <B>wxMIDI_FILT_TICK</B>
<UL>Both are the same code. Filter undefined 0xF9 messages (some equipment uses this as a 10ms 'tick').</UL><P>
<B>wxMIDI_FILT_FD</B>
<UL>Filter undefined 0xFD messages</UL><P>
<B>wxMIDI_FILT_UNDEFINED</B>
<UL>Filter undefined real-time messages =   (wxMIDI_FILT_F9 | wxMIDI_FILT_FD).</UL><P>
<B>wxMIDI_FILT_RESET</B>
<UL>Filter reset messages (0xFF).</UL><P>
<B>wxMIDI_FILT_REALTIME</B>
<UL>Filter all real-time messages =(wxMIDI_FILT_ACTIVE | wxMIDI_FILT_SYSEX | wxMIDI_FILT_CLOCK | wxMIDI_FILT_PLAY | wxMIDI_FILT_UNDEFINED | wxMIDI_FILT_RESET).</UL><P>
<B>wxMIDI_FILT_NOTE</B>
<UL>Filter note-on and note-off messages (0x90-0x9F and 0x80-0x8F).</UL><P>
<B>wxMIDI_FILT_CHANNEL_AFTERTOUCH</B>
<UL>Filter channel aftertouch (most MIDI controllers use this) (0xD0-0xDF).</UL><P>
<B>wxMIDI_FILT_POLY_AFTERTOUCH</B>
<UL>Filter per-note aftertouch messages (Ensoniq holds a patent on generating this on keyboards until June 2006) (0xA0-0xAF).</UL><P>
<B>wxMIDI_FILT_AFTERTOUCH</B>
<UL>Filter both channel and poly aftertouch = <BR>
 (wxMIDI_FILT_CHANNEL_AFTERTOUCH | wxMIDI_FILT_POLY_AFTERTOUCH)</UL><P>
<B>wxMIDI_FILT_PROGRAM</B>
<UL>Filter Program change messages (0xC0-0xCF).</UL><P>
<B>wxMIDI_FILT_CONTROL</B>
<UL>Filter Control Change messages (0xB0-0xBF).</UL><P>
<B>wxMIDI_FILT_PITCHBEND</B>
<UL>Filetr Pitch Bender messages (0xE0-0xEF).</UL><P>
<B>wxMIDI_FILT_MTC</B>
<UL>Filter MIDI Time Code messages (0xF1).</UL><P>
<B>wxMIDI_FILT_SONG_POSITION</B>
<UL>Filetr Song Position messages (0xF2).</UL><P>
<B>wxMIDI_FILT_SONG_SELECT</B>
<UL>Filter Song Select messages (0xF3).</UL><P>
<B>wxMIDI_FILT_TUNE</B>
<UL>Filter Tuning request messages (0xF6).</UL><P>
<B>wxMIDI_FILT_SYSTEMCOMMON</B>
<UL>Filter all System Common messages (MTC, song position, song select, tune request)
=(wxMIDI_FILT_MTC | wxMIDI_FILT_SONG_POSITION | wxMIDI_FILT_SONG_SELECT | wxMIDI_FILT_TUNE).</UL><P>

<!-- ======================================================================================= -->


<HR>
<a name="wxMidiErrorCodes"/>
<H2>wxMidiError codes</H2>

<A name="wxMIDI_NO_ERROR"/>
<B>wxMIDI_NO_ERROR</B>
<UL>No error. The requested operation succedeed.</UL><P>

<A name="wxMIDI_ERROR_HostError"/>
<B>wxMIDI_ERROR_HostError</B>
<UL>Portmidi reported a host error. You have to call 
<a href="wxMidiSystem.htm#wxMidiSystemGetHostErrorText">wxMidiSystem::GetHostErrorText</a>
to get more details about the error.
</UL><P>

<A name="wxMIDI_ERROR_InvalidDeviceId"/>
<B>wxMIDI_ERROR_InvalidDeviceId</B>
<UL>Invalid device ID. The ID is out of range (less than zero or greater or equal than the value returned by <A href="wxMidiSystem.htm#wxMidiCountDevices">wxMidiSystem::CountDevices</A>. Or it is an input device and it is being used to construct a wxMidiOutDevice, or viceversa.</UL><P>

<A name="wxMIDI_ERROR_InsufficientMemory"/>
<B>wxMIDI_ERROR_InsufficientMemory</B>
<UL>Insufficient memory.</UL><P>

<A name="wxMIDI_ERROR_BufferTooSmall"/>
<B>wxMIDI_ERROR_BufferTooSmall</B>
<UL>PortMidi reports a 'Buffer too small' error. This should not happen as wxMidi takes care
of all buffer allocation.</UL><P>

<A name="wxMIDI_ERROR_BadPtr"/>
<B>wxMIDI_ERROR_BadPtr</B>
<UL>PortMidi reports a `Bad pointer error'. This should not happen as wxMidi deals with PmDevices
inside objects wxMidiDevice, and so, user has no need to deal with pointers to PmDevices.</UL><P>

<A name="wxMIDI_ERROR_InternalError"/>
<B>wxMIDI_ERROR_InternalError</B>
<UL>Portmidi reported an 'Internal Error'. Sorry, no more information.</UL><P>

<A name="wxMIDI_ERROR_BufferOverflow"/>
<B>wxMIDI_ERROR_BufferOverflow</B>
<UL>PortMidi reported a 'Buffer overflow'. I'm not sure about the meaning of this error. Does it refer to internal
portmidi buffers? Is it for buffers allocated by user? In this last case I think that this error should not happen as
wxMidi takes care
of all buffer allocation.</UL><P>
</UL><P>

<A name="wxMIDI_ERROR_BadData"/>
<B>wxMIDI_ERROR_BadData</B>
<UL>PortMidi reported an 'Invalid MIDI message Data' such as illegal MIDI data or a missing EOX.</UL><P>

<A name="wxMIDI_ERROR_BufferMaxSize"/>
<B>wxMIDI_ERROR_BufferMaxSize</B>
<UL>Portmidi informs that 'buffer is already as large as it can be'. I do not know in which context is this
error reported and what is its meaning.</UL><P>

<A name="wxMIDI_ERROR_AlreadyListening"/>
<B>wxMIDI_ERROR_AlreadyListening</B>
<UL>Informative error. A second call to method
<A href="wxMidiDevice.htm#wxMidiInDeviceStartListening">wxMidiInDevice::StartListening</A>
without previously calling method
<A href="wxMidiDevice.htm#wxMidiInDeviceStopListening">wxMidiInDevice::StopListening</A>.
The lisening thread is left active.
</UL><P>

<A name="wxMIDI_ERROR_CreateThread"/>
<B>wxMIDI_ERROR_CreateThread</B>
<UL>An error ocurred during a call to 
<A href="wxMidiDevice.htm#wxMidiInDeviceStartListening">wxMidiInDevice::StartListening</A>.
The error ocurred while trying to create the wxThread object.</UL><P>

<A name="wxMIDI_ERROR_StartThread"/>
<B>wxMIDI_ERROR_StartThread</B>
<UL>An error ocurred during a call to 
<A href="wxMidiDevice.htm#wxMidiInDeviceStartListening">wxMidiInDevice::StartListening</A>.
The error ocurred after successful creation of the wxThread object, while starting the thread execution.</UL><P>

<A name="wxMIDI_ERROR_BadSysExMsg_Start"/>
<B>wxMIDI_ERROR_BadSysExMsg_Start</B>
<UL>The wxByte string received as parameter to create a wxMidiSysExMessage object does not start with 0xF0
(start-of-sysex status byte).</UL><P>

<A name="wxMIDI_ERROR_BadSysExMsg_Length"/>
<B>wxMIDI_ERROR_BadSysExMsg_Length</B>
<UL>The wxByte string received as parameter to create a wxMidiSysExMessage object is greater than 10000 or 
the end-of-sysex staus byte (0xF7) is not found.</UL><P>

<A name="wxMIDI_ERROR_NoDataAvailable"/>
<B>wxMIDI_ERROR_NoDataAvailable</B>
<UL>You called method
<A href="wxMidiDevice.htm#wxMidiInDeviceRead">wxMidiInDevice::Read</A> but there is no message waiting
to be delivered. You have to call Read method only after an wxEVT_MIDI_INPUT event takes place or after the
method
<A href="wxMidiDevice.htm#wxMidiInDevicePoll">wxMidiInDevice::Poll</A> reports that there is a message waiting.</UL><P>




</FONT></BODY></HTML>
